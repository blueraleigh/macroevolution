% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mk_epoch.R
\name{make.mk.epoch}
\alias{make.mk.epoch}
\title{Mk epoch model}
\usage{
make.mk.epoch(phy, x, rate, epochs, levels, ambig)
}
\arguments{
\item{phy}{An object of class \code{tree}.}

\item{x}{A vector of character states for tips in \code{phy}. May be a
character vector or an integer vector.}

\item{rate}{An object of class \code{ratematrix.mk.epoch}. See documenatation
for \code{make.ratematrix.mk.epoch}.}

\item{epochs}{An optional vector of epoch boundaries. Epoch boundaries are
assumed to be specified as time units before present. If this argument is
not missing it must be the case that the \code{rate} argument specifies a
rate matrix for each epoch. The number of epochs is given by 1 plus the
number of epoch boundaries.}

\item{levels.}{A vector of factor levels representing the different states
for the character. If \code{x} is a character vector this argument must be
supplied so that character states can be mapped to integers. In such a case,
the integer value of a character state is its index position in this vector.
If \code{x} is an integer vector this argument is unnecessary.}

\item{ambig.}{An optional list with names that match to character states
in \code{x}. If present, each list item represents a mapping from the
ambiguous coding state (represented by the name of the list item) to a
set of non-ambiguous states (represented by the value of the list item).}
}
\value{
A closure that inherits class \code{mk.epoch}, which is a function
 that computes the log likelihood of \code{x} given a vector of transtion
 rate parameters.
}
\description{
An Mk model that allows the evolution of a character in different
non-overlapping time periods (epochs) to evolve under different
transition rate matrices.
}
\examples{
  library(macroevolution)
  data(snaketree)

  phy = read.newick(text=snaketree)

  # assume 2 character states, three epochs
  # assume a fully symmetric rate matrix for each
  # epoch, but allow for a different rate in each epoch
  layout = array(0, c(2, 2, 3))
  layout[, , 1] = 1
  layout[, , 1] = 2
  layout[, , 1] = 3

  rate = make.ratematrix.mk.epoch(layout, covarion=FALSE)

  # make up some tip states
  x = structure(c(rep(1, 10), rep(2, Ntip(phy)-10)), names=tiplabels(phy))

  # epoch boundaries, which imply one epoch from 0 - 2 Ma, another from
  # 2 Ma - 8 Ma, and a final from 8 Ma - max(ages(phy)) Ma
  epochs = c(2, 8)

  # quick visual of the "data" and epochs
  L = plot(phy)
  abline(v=max(ages(phy))-epochs, col=2, lty=2)
  points(L[[1]][1:10, 1], L[[1]][1:10, 3], pch=21, bg=8)

  lik = make.mk.epoch(phy, x, rate, epochs)

  # notice how param 1 is optimized to lower bound. this makes sense given
  # data can be explained by 2 transitions, one in each of the more ancient
  # epochs, and no transitions in the most recent epoch
  optim(runif(3, 0, .1), lik, method="L-BFGS-B", lower=1e-6, upper=1, control=list(fnscale=-1))
}
\author{
Michael C. Grundler
}
